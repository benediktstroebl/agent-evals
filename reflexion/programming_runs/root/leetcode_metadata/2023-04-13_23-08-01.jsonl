{"code": "\nclass Solution():\n\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        '\\n    There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given an integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given\\xa0an array coins of size n where coins[i] can be either 0 or 1, where 1 indicates the presence of a coin in the vertex i.\\n    Initially, you choose to start at any vertex in\\xa0the tree.\\xa0Then, you can perform\\xa0the following operations any number of times:\\n    Collect all the coins that are at a distance of at most 2 from the current vertex, or\\n    Move to any adjacent vertex in the tree.\\n    Find the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex.\\n    Note that if you pass an edge several times, you need to count it into the answer several times.\\n    '\n        from collections import defaultdict\n        from typing import List\n\n        def dfs(node: int, parent: int) -> int:\n            total = coins[node]\n            for neighbor in graph[node]:\n                if (neighbor != parent):\n                    total += dfs(neighbor, node)\n            return total\n\n        def find_min_edges(node: int, parent: int) -> int:\n            min_edges = 0\n            for neighbor in graph[node]:\n                if (neighbor != parent):\n                    min_edges = max(min_edges, (find_min_edges(neighbor, node) + coins[neighbor]))\n            return min_edges\n        graph = defaultdict(list)\n        for edge in edges:\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n        total_coins = sum(coins)\n        if (total_coins == 0):\n            return 0\n        min_edges = float('inf')\n        for i in range(len(coins)):\n            if (coins[i] == 1):\n                min_edges = min(min_edges, (dfs(i, (- 1)) + find_min_edges(i, (- 1))))\n        return (((2 * (total_coins - 1)) - min_edges) if (min_edges != float('inf')) else 0)\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def minimumTime(self, grid: List[List[int]]) -> int:\n        '\\n    You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\\n    You are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\\n    Return the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.\\n    '\n        from heapq import heappush, heappop\n        from typing import List\n        (m, n) = (len(grid), len(grid[0]))\n        visited = [([False] * n) for _ in range(m)]\n        min_heap = [(grid[0][0], 0, 0)]\n        directions = [(0, 1), (1, 0), (0, (- 1)), ((- 1), 0)]\n        while min_heap:\n            (time, row, col) = heappop(min_heap)\n            if ((row == (m - 1)) and (col == (n - 1))):\n                return time\n            if (not visited[row][col]):\n                visited[row][col] = True\n                for (dr, dc) in directions:\n                    (new_row, new_col) = ((row + dr), (col + dc))\n                    if ((0 <= new_row < m) and (0 <= new_col < n)):\n                        new_time = max(time, grid[new_row][new_col])\n                        heappush(min_heap, (new_time, new_row, new_col))\n        return (- 1)\n", "status": "Wrong Answer", "reward": false, "info": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 30912000, "question_id": "2711", "elapsed_time": 3206, "compare_result": "00000000000000000000001000000000100000000", "code_output": "6", "std_output": "", "last_testcase": "[[0,1,3,2],[5,1,2,5],[4,3,8,6]]", "expected_output": "7", "task_finish_time": 1681442094738, "total_correct": 2, "total_testcases": 41, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933391838", "input_formatted": "[[0,1,3,2],[5,1,2,5],[4,3,8,6]]", "input": "[[0,1,3,2],[5,1,2,5],[4,3,8,6]]", "status_msg": "Wrong Answer", "state": "SUCCESS"}}
{"code": "\n    # Check if the constructed word matches the given lcp matrix\nclass Solution():\n\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        '\\n    We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\\n    lcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\\n    Given an\\xa0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\\n    A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and \\'b\\' comes before \\'c\\'.\\n    '\n        from typing import List\n        n = len(lcp)\n        word = (['a'] * n)\n        for i in range(1, n):\n            for j in range(i, n):\n                if (lcp[(i - 1)][j] == lcp[i][(j - 1)]):\n                    word[j] = chr((((ord(word[(j - 1)]) + lcp[i][j]) - lcp[(i - 1)][j]) + 1))\n                elif (lcp[(i - 1)][j] < lcp[i][(j - 1)]):\n                    word[j] = chr(((ord(word[(j - 1)]) + lcp[i][j]) - lcp[(i - 1)][j]))\n                else:\n                    word[j] = chr(((ord(word[(j - 1)]) + lcp[i][j]) - lcp[i][(j - 1)]))\n        for i in range(n):\n            for j in range(i, n):\n                common_prefix = 0\n                for k in range(min((n - i), (n - j))):\n                    if (word[(i + k)] == word[(j + k)]):\n                        common_prefix += 1\n                    else:\n                        break\n                if (lcp[i][j] != common_prefix):\n                    return ''\n        return ''.join(word)\n", "status": "Wrong Answer", "reward": false, "info": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 75504000, "question_id": "2708", "elapsed_time": 2300, "compare_result": "0011100010011111100000000000000000000001111111111111100", "code_output": "\"\"", "std_output": "", "last_testcase": "[[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]", "expected_output": "\"abab\"", "task_finish_time": 1681442377544, "total_correct": 24, "total_testcases": 55, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933393364", "input_formatted": "[[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]", "input": "[[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]", "status_msg": "Wrong Answer", "state": "SUCCESS"}}
{"code": "\nclass Solution():\n\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        '\\n    You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:\\n    For a query of type 1, queries[i]\\xa0= [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-indexed.\\n    For a query of type 2, queries[i]\\xa0= [2, p, 0]. For every index 0 <= i < n, set\\xa0nums2[i] =\\xa0nums2[i]\\xa0+ nums1[i]\\xa0* p.\\n    For a query of type 3, queries[i]\\xa0= [3, 0, 0]. Find the sum of the elements in nums2.\\n    Return an array containing all the answers to the third type\\xa0queries.\\n    '\n        result = []\n        for query in queries:\n            if (query[0] == 1):\n                (l, r) = (query[1], query[2])\n                for i in range(l, (r + 1)):\n                    nums1[i] = (1 - nums1[i])\n            elif (query[0] == 2):\n                p = query[1]\n                for i in range(len(nums1)):\n                    nums2[i] += (nums1[i] * p)\n            elif (query[0] == 3):\n                result.append(sum(nums2))\n        return result\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def minimumScore(self, s: str, t: str) -> int:\n        '\\n    You are given two strings s and t.\\n    You are allowed to remove any number of characters from the string t.\\n    The score of the string is 0 if no characters are removed from the string t, otherwise:\\n    Let left be the minimum index among all removed characters.\\n    Let right be the maximum index among all removed characters.\\n    Then the score of the string is right - left + 1.\\n    Return the minimum possible score to make t\\xa0a subsequence of s.\\n    A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\\n    '\n        (n, m) = (len(s), len(t))\n        min_score = float('inf')\n\n        def dfs(i: int, j: int, left: int, right: int) -> None:\n            nonlocal min_score\n            if (j == m):\n                if ((left != (- 1)) and (right != (- 1))):\n                    min_score = min(min_score, ((right - left) + 1))\n                return\n            if (i == n):\n                return\n            if (s[i] == t[j]):\n                dfs((i + 1), (j + 1), left, right)\n            else:\n                dfs((i + 1), j, left, right)\n                if (left == (- 1)):\n                    dfs((i + 1), (j + 1), i, i)\n                else:\n                    dfs((i + 1), (j + 1), left, i)\n        dfs(0, 0, (- 1), (- 1))\n        return (min_score if (min_score != float('inf')) else 0)\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def minimumVisitedCells(self, grid: List[List[int]]) -> int:\n        '\\n    You are given a 0-indexed m x n integer matrix grid. Your initial position is at the top-left cell (0, 0).\\n    Starting from the cell (i, j), you can move to one of the following cells:\\n    Cells (i, k) with j < k <= grid[i][j] + j (rightward movement), or\\n    Cells (k, j) with i < k <= grid[i][j] + i (downward movement).\\n    Return the minimum number of cells you need to visit to reach the bottom-right cell (m - 1, n - 1). If there is no valid path, return -1.\\n    '\n        from heapq import heappush, heappop\n        (m, n) = (len(grid), len(grid[0]))\n        visited = [([float('inf')] * n) for _ in range(m)]\n        heap = [(0, 0, 0)]\n        while heap:\n            (steps, i, j) = heappop(heap)\n            if ((i == (m - 1)) and (j == (n - 1))):\n                return steps\n            if (steps >= visited[i][j]):\n                continue\n            visited[i][j] = steps\n            steps_to_move = grid[i][j]\n            for k in range(1, (steps_to_move + 1)):\n                if (((j + k) < n) and ((steps + 1) < visited[i][(j + k)])):\n                    heappush(heap, ((steps + 1), i, (j + k)))\n                if (((i + k) < m) and ((steps + 1) < visited[(i + k)][j])):\n                    heappush(heap, ((steps + 1), (i + k), j))\n        return (- 1)\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n        '\\n    You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:\\n    Chose two indices i and j, and swap the ith fruit of basket1 with the jth fruit of basket2.\\n    The cost of the swap is min(basket1[i],basket2[j]).\\n    Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\\n    Return the minimum cost to make both the baskets equal or -1 if impossible.\\n    '\n        from collections import Counter\n        basket1_counter = Counter(basket1)\n        basket2_counter = Counter(basket2)\n        diff = list(((basket1_counter - basket2_counter) + (basket2_counter - basket1_counter)))\n        if ((len(diff) % 2) != 0):\n            return (- 1)\n        diff.sort()\n        min_cost = 0\n        for i in range(0, len(diff), 2):\n            min_cost += min(diff[i], diff[(i + 1)])\n        return min_cost\n", "status": "Wrong Answer", "reward": false, "info": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 47980000, "question_id": "2689", "elapsed_time": 866, "compare_result": "1001110100000110111010100000000000000000", "code_output": "4", "std_output": "", "last_testcase": "[2,3,4,1]\n[3,2,5,1]", "expected_output": "-1", "task_finish_time": 1681443264503, "total_correct": 12, "total_testcases": 40, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933398449", "input_formatted": "[2,3,4,1], [3,2,5,1]", "input": "[2,3,4,1]\n[3,2,5,1]", "status_msg": "Wrong Answer", "state": "SUCCESS"}}
{"code": "\nclass Solution():\n\n    def countQuadruplets(self, nums: List[int]) -> int:\n        '\\n    Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.\\n    A quadruplet (i, j, k, l) is increasing if:\\n    0 <= i < j < k < l < n, and\\n    nums[i] < nums[k] < nums[j] < nums[l].\\n    '\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            for j in range((i + 1), n):\n                for k in range((j + 1), n):\n                    for l in range((k + 1), n):\n                        if (nums[i] < nums[k] < nums[j] < nums[l]):\n                            count += 1\n        return count\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        '\\n    You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.\\n    Divide the marbles into the k bags according to the following rules:\\n    No bag is empty.\\n    If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.\\n    If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].\\n    The score after distributing the marbles is the sum of the costs of all the k bags.\\n    Return the difference between the maximum and minimum scores among marble distributions.\\n    '\n        n = len(weights)\n        dp = [([float('inf')] * n) for _ in range(k)]\n        for i in range(n):\n            dp[0][i] = sum(weights[:(i + 1)])\n        for bag in range(1, k):\n            for end in range(n):\n                for start in range(end):\n                    cost = (dp[(bag - 1)][start] + sum(weights[start:(end + 1)]))\n                    dp[bag][end] = min(dp[bag][end], cost)\n        min_score = float('inf')\n        max_score = float('-inf')\n        for i in range(k):\n            min_score = min(min_score, dp[i][(- 1)])\n            max_score = max(max_score, dp[i][(- 1)])\n        return (max_score - min_score)\n", "status": "Wrong Answer", "reward": false, "info": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 783544000, "question_id": "2681", "elapsed_time": 1319, "compare_result": "0010000100010000000000000000000101000010000000010000010100000000100000000000000000001000000000000000000", "code_output": "1", "std_output": "", "last_testcase": "[1,3,5,1]\n2", "expected_output": "4", "task_finish_time": 1681443656053, "total_correct": 11, "total_testcases": 103, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933400717", "input_formatted": "[1,3,5,1], 2", "input": "[1,3,5,1]\n2", "status_msg": "Wrong Answer", "state": "SUCCESS"}}
{"code": "\nclass Solution():\n\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        '\\n    There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\\n    Return the length of the shortest cycle in the graph. If no cycle exists, return -1.\\n    A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.\\n    '\n        from collections import defaultdict\n        from typing import List\n        graph = defaultdict(list)\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        min_cycle = float('inf')\n\n        def dfs(node, parent, depth):\n            nonlocal min_cycle\n            if visited[node]:\n                min_cycle = min(min_cycle, (depth - visited[node]))\n                return\n            visited[node] = depth\n            for neighbor in graph[node]:\n                if (neighbor != parent):\n                    dfs(neighbor, node, (depth + 1))\n        for i in range(n):\n            visited = ([0] * n)\n            dfs(i, (- 1), 1)\n        return (min_cycle if (min_cycle != float('inf')) else (- 1))\n", "status": "Wrong Answer", "reward": false, "info": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 15828000, "question_id": "2671", "elapsed_time": 2595, "compare_result": "0100000000001100100100100100100010001000100000000000000000000000000000000000000000000000", "code_output": "-2", "std_output": "", "last_testcase": "7\n[[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]", "expected_output": "3", "task_finish_time": 1681443874105, "total_correct": 11, "total_testcases": 88, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933402049", "input_formatted": "7, [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]", "input": "7\n[[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]", "status_msg": "Wrong Answer", "state": "SUCCESS"}}
