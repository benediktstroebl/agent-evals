{"code": "\nclass Solution():\n\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        '\\n    You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\\n    The second greater integer of nums[i] is nums[j] such that:\\n    j > i\\n    nums[j] > nums[i]\\n    There exists exactly one index k such that nums[k] > nums[i] and i < k < j.\\n    If there is no such nums[j], the second greater integer is considered to be -1.\\n    For example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3,\\xa0and that of 3 and 4 is -1.\\n    Return an integer array answer, where answer[i] is the second greater integer of nums[i].\\n    '\n        result = ([(- 1)] * len(nums))\n        for i in range(len(nums)):\n            first_greater_index = (- 1)\n            second_greater_index = (- 1)\n            for j in range((i + 1), len(nums)):\n                if (nums[j] > nums[i]):\n                    if ((first_greater_index == (- 1)) or (nums[j] < nums[first_greater_index])):\n                        second_greater_index = first_greater_index\n                        first_greater_index = j\n                    elif ((second_greater_index == (- 1)) or (nums[j] < nums[second_greater_index])):\n                        second_greater_index = j\n            if (second_greater_index != (- 1)):\n                result[i] = nums[second_greater_index]\n        return result\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\n        '\\n    You are given two positive integer arrays nums and target, of the same length.\\n    In one operation, you can choose any two distinct indices i and j where 0 <= i, j < nums.length and:\\n    set nums[i] = nums[i] + 2 and\\n    set nums[j] = nums[j] - 2.\\n    Two arrays are considered to be similar if the frequency of each element is the same.\\n    Return the minimum number of operations required to make nums similar to target. The test cases are generated such that nums can always be similar to target.\\n    '\n        from collections import Counter\n        diff_counter = Counter()\n        for (num, tar) in zip(nums, target):\n            diff = ((num - tar) % 4)\n            diff_counter[diff] += 1\n        operations = 0\n        for (diff, count) in diff_counter.items():\n            if (diff == 0):\n                continue\n            elif (diff == 2):\n                operations += (count // 2)\n            else:\n                operations += ((count // 4) * 2)\n        return operations\n", "status": "Wrong Answer", "reward": false, "info": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 32652000, "question_id": "2539", "elapsed_time": 856, "compare_result": "00100000000000000000000000000000", "code_output": "1", "std_output": "", "last_testcase": "[8,12,6]\n[2,14,10]", "expected_output": "2", "task_finish_time": 1681522449111, "total_correct": 1, "total_testcases": 32, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933893731", "input_formatted": "[8,12,6], [2,14,10]", "input": "[8,12,6]\n[2,14,10]", "status_msg": "Wrong Answer", "state": "SUCCESS"}}
{"code": "\nclass Solution():\n\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        '\\n    You are given two 0-indexed arrays nums and cost consisting each of n positive integers.\\n    You can do the following operation any number of times:\\n    Increase or decrease any element of the array nums by 1.\\n    The cost of doing one operation on the ith element is cost[i].\\n    Return the minimum total cost such that all the elements of the array nums become equal.\\n    '\n        from typing import List\n        n = len(nums)\n        min_cost = float('inf')\n        min_num = (min(nums) - max(cost))\n        max_num = (max(nums) + max(cost))\n        for target in range(min_num, (max_num + 1)):\n            total_cost = 0\n            for i in range(n):\n                total_cost += (abs((nums[i] - target)) * cost[i])\n            min_cost = min(min_cost, total_cost)\n        return min_cost\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        '\\n    There is an undirected tree with n nodes labeled from 0 to n - 1.\\n    You are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\\n    You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\\n    Return the maximum number of edges you can delete, such that every connected component in the tree has the same value.\\n    '\n        from collections import defaultdict, deque\n        from typing import List\n        total_sum = sum(nums)\n        graph = defaultdict(list)\n        for (a, b) in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        def dfs(node, parent):\n            nonlocal count\n            component_sum = nums[node]\n            for neighbor in graph[node]:\n                if (neighbor != parent):\n                    component_sum += dfs(neighbor, node)\n            if ((component_sum * 2) == total_sum):\n                count += 1\n                return 0\n            return component_sum\n        count = 0\n        dfs(0, (- 1))\n        return (count if (count > 0) else 0)\n", "status": "Wrong Answer", "reward": false, "info": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 45600000, "question_id": "2531", "elapsed_time": 1349, "compare_result": "0110110110111111111011111111111111111111000", "code_output": "0", "std_output": "", "last_testcase": "[6,2,2,2,6]\n[[0,1],[1,2],[1,3],[3,4]]", "expected_output": "2", "task_finish_time": 1681522842797, "total_correct": 35, "total_testcases": 43, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933894998", "input_formatted": "[6,2,2,2,6], [[0,1],[1,2],[1,3],[3,4]]", "input": "[6,2,2,2,6]\n[[0,1],[1,2],[1,3],[3,4]]", "status_msg": "Wrong Answer", "state": "SUCCESS"}}
{"code": "\nclass Solution():\n\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:\n        '\\n    You are given an integer array nums and two integers minK and maxK.\\n    A fixed-bound subarray of nums is a subarray that satisfies the following conditions:\\n    The minimum value in the subarray is equal to minK.\\n    The maximum value in the subarray is equal to maxK.\\n    Return the number of fixed-bound subarrays.\\n    A subarray is a contiguous part of an array.\\n    '\n        count = 0\n        for i in range(len(nums)):\n            min_val = float('inf')\n            max_val = float('-inf')\n            for j in range(i, len(nums)):\n                min_val = min(min_val, nums[j])\n                max_val = max(max_val, nums[j])\n                if ((min_val == minK) and (max_val == maxK)):\n                    if all(((minK <= num <= maxK) for num in nums[i:(j + 1)])):\n                        count += 1\n                elif ((min_val < minK) or (max_val > maxK)):\n                    break\n                else:\n                    continue\n        return count\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def lengthOfLIS(self, nums: List[int], k: int) -> int:\n        '\\n    You are given an integer array nums and an integer k.\\n    Find the longest subsequence of nums that meets the following requirements:\\n    The subsequence is strictly increasing and\\n    The difference between adjacent elements in the subsequence is at most k.\\n    Return the length of the longest subsequence that meets the requirements.\\n    A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\\n    '\n        if (not nums):\n            return 0\n        n = len(nums)\n        dp = ([1] * n)\n        for i in range(1, n):\n            for j in range(i):\n                if ((nums[i] > nums[j]) and ((nums[i] - nums[j]) <= k)):\n                    dp[i] = max(dp[i], (dp[j] + 1))\n        return max(dp)\n", "status": "Submission Timed-Out", "reward": false, "info": {"state": "STARTED"}}
{"code": "\nclass Solution():\n\n    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:\n        '\\n    You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.\\n    Return the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.\\n    '\n        from typing import List\n        (m, n) = (len(grid), len(grid[0]))\n        mod = ((10 ** 9) + 7)\n        dp = [[([0] * k) for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                for p in range(k):\n                    if ((i == 0) and (j == 0)):\n                        dp[i][j][(grid[i][j] % k)] = 1\n                    else:\n                        if (i > 0):\n                            dp[i][j][((p + grid[i][j]) % k)] += dp[(i - 1)][j][p]\n                            dp[i][j][((p + grid[i][j]) % k)] %= mod\n                        if (j > 0):\n                            dp[i][j][((p + grid[i][j]) % k)] += dp[i][(j - 1)][p]\n                            dp[i][j][((p + grid[i][j]) % k)] %= mod\n        return (dp[(m - 1)][(n - 1)][0] % mod)\n", "status": "Accepted", "reward": true, "info": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "6241 ms", "memory": 94248000, "question_id": "2521", "elapsed_time": 6425, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681523308980, "total_correct": 88, "total_testcases": 88, "runtime_percentile": 13.327199999999637, "status_memory": "94.2 MB", "memory_percentile": 80.41639999999995, "pretty_lang": "Python3", "submission_id": "933896549", "status_msg": "Accepted", "state": "SUCCESS"}}
